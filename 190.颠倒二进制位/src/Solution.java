/*
颠倒给定的 32 位无符号整数的二进制位。

提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，
并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
    因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

 */

//逐位移动
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ret = 0;
        //每次取n的最末位，左移到其对称的位置，然后n右移一位，循环遍历32个数字。
         for(int i = 0; i < 32 && n != 0; ++i){
             ret |= ((n & 1)<<(31-i));
             n >>>= 1;
        }
        return ret;
    }
}

/*//位运算分治
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        //分块掩码
        int M1 = 0x55555555; //(0101 0101 0101 0101 0101 0101 0101 0101)
        int M2 = 0x33333333; //(0011 0011 0011 0011 0011 0011 0011 0011)
        int M4 = 0x0F0F0F0F; //(0000 1111 0000 1111 0000 1111 0000 1111)
        int M8 = 0x00FF00FF; //(0000 0000 1111 1111 0000 0000 1111 1111)

        //奇数位与偶数位对调
        n = ((n >>> 1) & M1) | ((n & M1) << 1);
        n = ((n >>> 2) & M2) | ((n & M2) << 2);
        n = ((n >>> 4) & M4) | ((n & M4) << 4);
        n = ((n >>> 8) & M8) | ((n & M8) << 8);
        n = (n >>> 16) | (n << 16);

        return n;
    }
}
 */